<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Working with tensors </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Working with tensors ">
    <meta name="generator" content="docfx 1.0.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="working-with-tensors">Working with tensors</h1>

<p>A <em>tensor</em> is an n-dimensional array of an arbitrary data type (for example <code>single</code> or <code>double</code>).
Tensors of data type <code>&#39;T</code> are implemented by the <a class="xref" href="../api/Tensor.Tensor-1.html">Tensor&lt;&#39;T&gt;</a> type.</p>
<p>A tensor can be either stored in host memory or in the memory of a GPU computing device.
Currenty only nVidia cards implementing the <a href="https://developer.nvidia.com/cuda-zone">CUDA API</a> are supported.
The API for host and GPU stored tensors is mostly equal, thus a program can make use of GPU accelerated operations without porting effort.</p>
<p>The tensor library provides functionality similar to <a href="http://docs.scipy.org/doc/numpy-1.10.0/reference/arrays.html">Numpy&#39;s Ndarray</a> and <a href="http://www.mathworks.com/help/matlab/matrices-and-arrays.html">MATLAB arrays</a>, including vector-wise operations, reshaping, slicing, broadcasting, masked assignment, reduction operations and BLAS operations.</p>
<p>This open source library is written in <a href="http://fsharp.org/">F#</a> and targets the <a href="https://github.com/dotnet/standard/blob/master/docs/versions/netstandard2.0.md">.NET Standard 2.0 platform</a> with Linux and Microsoft Windows as supported operating systems.</p>
<h2 id="architecture">Architecture</h2>
<p>To work with the tensor library, reference the <a href="https://www.nuget.org/packages/Tensor/">Tensor NuGet package</a> by running</p>
<pre><code>dotnet add package Tensor
</code></pre><p>inside your project directory and open the <code>Tensor</code> namespace within your source file.</p>
<pre><code class="lang-fsharp">open Tensor
</code></pre><p>The primary type you will work with is <a class="xref" href="../api/Tensor.Tensor-1.html">Tensor&lt;&#39;T&gt;</a>.
It provides functions to work with tensors regardless of their storage device.
The modules <a class="xref" href="../api/Tensor.HostTensor.html">HostTensor</a> and <a class="xref" href="../api/Tensor.CudaTensor.html">CudaTensor</a> contain additional functions that are only applicable to tensors stored in host or GPU memory respectively.</p>
<h2 id="creating-tensors">Creating tensors</h2>
<p>Let us create a $3 \times 2$ matrix, i.e. a two-dimensional tensor, of data type <code>int</code> filled with zeros in host memory.
For this purpose we use the <a class="xref" href="../api/Tensor.Tensor-1.zeros.html">Tensor&lt;&#39;T&gt;.zeros</a> function.</p>
<pre><code class="lang-fsharp">let z1 = Tensor&lt;int&gt;.zeros HostTensor.Dev [3L; 2L]
// z1 = [[0; 0]
//       [0; 0]
//       [0; 0]]
</code></pre><p>The type argument <code>int</code> tells the function which data type to use.
In many cases, it can be automatically inferred and thus omitted, but in this example there is not way for the compiler to automatically find out which data type to use.</p>
<p>The first argument to the <code>zeros</code> function specifies the device to use.
In this case we specified <a href="xref:Tensor.HostTensor.Dev">HostTensor.Dev</a> to store the tensor in host memory.
The second argument specifies the desired shape.
All shapes and indices in this tensor library are 64-bit integers.
Thus we have to use the <code>L</code> postfix when writing integer literals, i.e. <code>3L</code> instead of <code>3</code>.</p>
<p>Since creating tensors in host memory is a very common operation, the library also provides the shorter notation</p>
<pre><code class="lang-fsharp">let z1 = HostTensor.zeros&lt;int&gt; [3L; 2L]
// z1 = [[0; 0]
//       [0; 0]
//       [0; 0]]
</code></pre><p>to perform the same task.
These shorthands are available for all tensor creation function and listed in the <a class="xref" href="../api/Tensor.HostTensor.html">HostTensor</a> module.</p>
<p>Similarly, we can use the <a href="xref:Tensor.Tensor`1.ones">Tensor.ones</a> function to obtain a vector of data type <code>single</code> and size <code>3</code> filled with ones.</p>
<pre><code class="lang-fsharp">let o1 = Tensor&lt;single&gt;.ones HostTensor.Dev [3L]
// o1 = [0.0f; 0.0f; 0.0f]
</code></pre><p>The <a href="xref:Tensor.Tensor`1.identity">Tensor&lt;&#39;T&gt;.identity</a> function creates an identity matrix of the given size.</p>
<pre><code class="lang-fsharp">let id1 = Tensor&lt;float&gt;.identity HostTensor.Dev 3L
// id1 = [[1.0; 0.0; 0.0]
//        [0.0; 1.0; 0.0]
//        [0.0; 0.0; 1.0]]
</code></pre><p>This created a $3 \times 3$ identity matrix.</p>
<h3 id="scalar-tensors">Scalar tensors</h3>
<p>A scalar tensor is a tensor that has a dimensionality of zero.
It contains exactly one element and can be treated like a tensor of any other dimensionality.
However, for convenience, special functions are provided to make working with scalar tensors easier.</p>
<p>A scalar tensor can be created with the <a href="xref:Tensor.Tensor`1.scalar">Tensor&lt;&#39;T&gt;.scalar</a> function (or its corresponding <a href="xref:Tensor.HostTensor.scalar">HostTensor.scalar</a> shorthand).</p>
<pre><code class="lang-fsharp">let s1 = Tensor.scalar HostTensor.Dev 33.2
// s1 = 33.2
// s1.NDims = 0
// s1.Shape = []
// s1.NElems = 1L
</code></pre><p>Specifying an empty shape when using other creation methods, such as <a class="xref" href="../api/Tensor.Tensor-1.zeros.html">Tensor&lt;&#39;T&gt;.zeros</a>, will also create a scalar tensor.</p>
<p>The numeric value of a scalar tensor can be obtained (and changed) using the <a href="xref:Tensor.Tensor`1.Value">Tensor&lt;&#39;T&gt;.Value</a> property.</p>
<pre><code class="lang-fsharp">printfn &quot;The numeric value of s1 is %f.&quot; s1.Value
// The numeric value of s1 is 33.2.
</code></pre><p>If you try to use this property on a non-scalar tensor, an exception will be raised.</p>
<h3 id="host-only-creation-methods">Host-only creation methods</h3>
<p>Some tensor creation methods can only produce tensors stored in host memory, which, of course, can be transferred to GPU memory subsequently.
For example the <a href="xref:Tensor.HostTensor.init">HostTensor.init</a> function takes a function and uses it to compute the initial value of each element of the tensor.</p>
<pre><code class="lang-fsharp">let a = HostTensor.init [7L; 5L] (fun [i; j] -&gt; 5.0 * float i + float j)
// a =
//    [[   0.0000    1.0000    2.0000    3.0000    4.0000]
//     [   5.0000    6.0000    7.0000    8.0000    9.0000]
//     [  10.0000   11.0000   12.0000   13.0000   14.0000]
//     [  15.0000   16.0000   17.0000   18.0000   19.0000]
//     [  20.0000   21.0000   22.0000   23.0000   24.0000]
//     [  25.0000   26.0000   27.0000   28.0000   29.0000]
//     [  30.0000   31.0000   32.0000   33.0000   34.0000]]
</code></pre><p>The first argument specifies the shape of the tensor.
The second argument is a function that takes the n-dimensional index (zero-based) of an entry and computes its initial value; here we use the formula $5i + j$ where $i$ is the row and $j$ is the column of the matrix.
The data type (here <code>float</code>) is automatically inferred from the return type of the initialization function.</p>
<h3 id="creation-from-f-sequences-lists-and-arrays">Creation from F# sequences, lists and arrays</h3>
<p>The <a href="xref:Tensor.HostTensor.ofSeq">HostTensor.ofSeq</a> converts an <a href="https://en.wikibooks.org/wiki/F_Sharp_Programming/Sequences">F# sequence</a> of finite length into a one-dimensional tensor.</p>
<pre><code class="lang-fsharp">let seq1 = seq { for i=0 to 20 do if i % 3 = 0 then yield i } |&gt; HostTensor.ofSeq
// seq1 = [   0    3    6    9   12   15   18]
</code></pre><p>The example above creates a vector of all multiplies of 3 in the range between 0 and 20.</p>
<p>A list can be converted into a one-dimensional tensor using the <a href="xref:Tensor.HostTensor.ofList">HostTensor.ofList</a> function.
To convert an array into a tensor use the <a href="xref:Tensor.HostTensor.ofArray">HostTensor.ofArray</a> function.
The <a href="xref:Tensor.HostTensor.ofList2D">HostTensor.ofList2D</a> and <a href="xref:Tensor.HostTensor.ofArray2D">HostTensor.ofArray2D</a> take two-dimensional lists or arrays and convert them into tensors of respective shapes.</p>
<h3 id="conversion-to-f-sequences-lists-and-arrays">Conversion to F# sequences, lists and arrays</h3>
<p>Use the <a href="xref:Tensor.HostTensor.toSeq">HostTensor.toSeq</a> function to expose the elements of a tensor as a sequence.
If the tensor has more than one dimension, it is flattened before the operation is performed.</p>
<p>Use the <a href="xref:Tensor.HostTensor.toList">HostTensor.toList</a> or <a href="xref:Tensor.HostTensor.toList2D">HostTensor.toList2D</a> functions to convert a tensor into a list.
The <a href="xref:Tensor.HostTensor.toArray">HostTensor.toArray</a>, <a href="xref:Tensor.HostTensor.toArray2D">HostTensor.toArray2D</a>, <a href="xref:Tensor.HostTensor.toArray3D">HostTensor.toArray3D</a> convert a tensor into an array of respective dimensionality.</p>
<p>All these operations copy the elements of the tensor.</p>
<h2 id="printing-tensors-and-string-representation">Printing tensors and string representation</h2>
<p>Tensors can be printed using the <code>%A</code> format specifier of the standard <code>printf</code> function.</p>
<pre><code class="lang-fsharp">printfn &quot;The tensor seq1 is\n%A&quot; seq1
// The tensor seq1 is
// [   0    3    6    9   12   15   18]
</code></pre><p>The output of large tensors is automatically truncated to a reasonable size.
The corresponding string representation can also be accessed thorugh the <a href="xref:Tensor.Tensor`1.Pretty">Pretty</a> property.
The full (untruncated) string representation is available through the <a href="xref:Tensor.Tensor`1.Full">Full</a> property.
Use the <a href="xref:Tensor.Tensor`1.ToString">ToString</a> method when it is required to adjust the maximum number of elements that are printed before truncation occurs.</p>
<h2 id="accessing-individual-elements">Accessing individual elements</h2>
<p>Individual elements of a tensor can be accessed using the <code>tensor.[[idx0; idx1; ...; idxN]]</code> notation.
Zero-based indexing is used.</p>
<pre><code class="lang-fsharp">// a =
//    [[   0.0000    1.0000    2.0000    3.0000    4.0000]
//     [   5.0000    6.0000    7.0000    8.0000    9.0000]
//     [  10.0000   11.0000   12.0000   13.0000   14.0000]
//     [  15.0000   16.0000   17.0000   18.0000   19.0000]
//     [  20.0000   21.0000   22.0000   23.0000   24.0000]
//     [  25.0000   26.0000   27.0000   28.0000   29.0000]
//     [  30.0000   31.0000   32.0000   33.0000   34.0000]]
let v = a.[[1L; 1L]]
// v = 6.0
</code></pre><p>The above example accesses the element at index $1,1$.
Note that the indices are specified as 64-bit integers surrounded by double brackets (<code>[[</code> and <code>]]</code>) and separated using a semicolon.</p>
<p>Tensors are mutable objects.
An element can be changed using the <code>tensor.[[idx0; idx1; ...; idxN]] &lt;- newValue</code> notation.</p>
<pre><code class="lang-fsharp">a.[[2L; 2L]] &lt;- 55.
// a =
//    [[   0.0000    1.0000    2.0000    3.0000    4.0000]
//     [   5.0000    6.0000    7.0000    8.0000    9.0000]
//     [  10.0000   11.0000   55.0000   13.0000   14.0000]
//     [  15.0000   16.0000   17.0000   18.0000   19.0000]
//     [  20.0000   21.0000   22.0000   23.0000   24.0000]
//     [  25.0000   26.0000   27.0000   28.0000   29.0000]
//     [  30.0000   31.0000   32.0000   33.0000   34.0000]]
</code></pre><p>The above example changes the value at index $2,2$ to 55.</p>
<h2 id="slicing">Slicing</h2>
<p>Slicing creates a new view into an existing tensor.
Slicing is done using the <code>tensor.[rng0, rng1, ..., rngN]</code> notation.
Note that the ranges are specified within single brackets and separated using commas.</p>
<p>Let us select the first row of tensor a.</p>
<pre><code class="lang-fsharp">let a1 = a.[0, *]
</code></pre><p>The asterisk selects all elements of the specified dimension.
The result is a tensor of rank one (i.e. a vector) with the entries</p>
<pre><code>[   0.0000    1.0000    2.0000    3.0000    4.0000]
</code></pre><p>Since <code>a1</code> is a view of <code>a</code> it shares the same memory.
Changing an element of <code>a1</code> by assigning a new value to it</p>
<pre><code class="lang-fsharp">a1.[[1]] &lt;- 99.
</code></pre><p>changes the tensor <code>a</code> as well.
This can be seen by outputting <code>a1</code> and <code>a</code>.</p>
<pre><code class="lang-fsharp">printfn &quot;a1 is now\n%A&quot; a1
printfn &quot;a is now\n%A&quot; a
</code></pre><p>The corresponding output is</p>
<pre><code>a1 is now
[   0.0000   99.0000    2.0000    3.0000    4.0000]
a is now
[[   0.0000   99.0000    2.0000    3.0000    4.0000]
 [   5.0000    6.0000    7.0000    8.0000    9.0000]
 [  10.0000   11.0000   55.0000   13.0000   14.0000]
 [  15.0000   16.0000   17.0000   18.0000   19.0000]
 [  20.0000   21.0000   22.0000   23.0000   24.0000]
 [  25.0000   26.0000   27.0000   28.0000   29.0000]
 [  30.0000   31.0000   32.0000   33.0000   34.0000]]
</code></pre><p>The slicing notation can also be used for changing multiple elements of a tensor at once.
For example</p>
<pre><code class="lang-fsharp">let a2 : ArrayNDHostT&lt;float&gt; = ArrayNDHost.ones [5] 
a.[0, *] &lt;- a2
</code></pre><p>sets all elements of the first row of <code>a</code> to 1.
The tensor <code>a</code> is now</p>
<pre><code>[[   1.0000    1.0000    1.0000    1.0000    1.0000]
 [   5.0000    6.0000    7.0000    8.0000    9.0000]
 [  10.0000   11.0000   55.0000   13.0000   14.0000]
 [  15.0000   16.0000   17.0000   18.0000   19.0000]
 [  20.0000   21.0000   22.0000   23.0000   24.0000]
 [  25.0000   26.0000   27.0000   28.0000   29.0000]
 [  30.0000   31.0000   32.0000   33.0000   34.0000]]
</code></pre><h3 id="slicing-operations">Slicing operations</h3>
<p>Consider the two-dimensional tensor <code>a</code> of shape $7 \times 5$ and the four-dimensional tensor <code>b</code> of shape $1 \times 2 \times 3 \times 4$.
A slice range can be one of the following.</p>
<ul>
<li>A range, e.g. <code>1..3</code>. Selects the specified elements in the corresponding dimension. For example <code>a.[1..3, 0..2]</code> is the $3 \times 3$ sub-tensor of <code>a</code> containing rows 1, 2, 3 and columns 0, 1, 2. <strong>The ending index is inclusive.</strong></li>
<li>A partial range, e.g. <code>1..</code> or <code>..3</code>. This selects all elements in the corresponding dimension to the end or from the beginning respectively. Thus <code>a.[1.., ..3]</code> is equivalent to <code>a.[1..6, 0..3]</code>.</li>
<li>An asterisk <code>*</code>. Selects all elements in the corresponding dimension. For example <code>a.[1..3, *]</code> is equivalent to <code>a.[1..3, 0..4]</code>.</li>
<li>An integer. The corresponding dimension collapses, e.g. <code>a.[*, 0]</code> specifies a one-dimensional tensor of shape $7$ corresponding to the first column of <code>a</code>.</li>
<li>The special identifier <code>NewAxis</code>. It inserts a new axis of size one at the given position. For example <code>a.[*, NewAxis, *]</code> produces a view of shape $7 \times 1 \times 5$.</li>
<li>The special identifier <code>Fill</code>. It fills any dimensions not specified (if any) with an asterisk <code>*</code>. For example <code>b.[0, Fill, 2]</code> is equivalent to <code>b.[0, *, *, 4]</code> and results into a two-dimensional view into tensor <code>b</code>.</li>
</ul>
<p>All slice range operators can be combined arbitrarily.</p>
<p>The reader should note that the result of selecting a single element using the slicing operator, e.g. <code>a.[1,1]</code>, is a <em>tensor</em> of dimension zero sharing the same memory as <code>a</code>.</p>
<h2 id="shape-operations">Shape operations</h2>
<h3 id="getting-the-shape">Getting the shape</h3>
<p>The shape of a tensor can be accessed using the function <code>ArrayND.shape</code> or using the <code>Shape</code> property.
Both methods return a list.
The rank (number of dimensions) can be accessed using the function <code>ArrayND.nDims</code> or with the <code>NDims</code> property.
The number of elements can be accessed using the function <code>ArrayND.nElems</code> or with the <code>NElems</code> property.
For example</p>
<pre><code class="lang-fsharp">printfn &quot;a has shape %A, rank %d and %d elements.&quot; a.Shape a.NDims a.NElems
</code></pre><p>prints</p>
<pre><code>a has shape [7; 5], rank 2 and 35 elements.
</code></pre><h3 id="reshaping">Reshaping</h3>
<p>Reshaping changes the shape of the tensor while keeping the number of elements constant.</p>
<p>For example consider the $4 \times 4$ matrix <code>b</code>,</p>
<pre><code class="lang-fsharp">let b = ArrayNDHost.initIndexed [4; 4] (fun [y; x] -&gt; 4 * y + x)
</code></pre><p>with value</p>
<pre><code>[[   0    1    2    3]
 [   4    5    6    7]
 [   8    9   10   11]
 [  12   13   14   15]]
</code></pre><p>We can use the <code>ArrayND.reshape</code> function to transform this matrix into a vector of length 16.</p>
<pre><code class="lang-fsharp">let b1 = ArrayND.reshape [16] b
</code></pre><p>Now <code>b1</code> has the value</p>
<pre><code>[   0    1    2    3    4    5 ...   12   13   14   15]
</code></pre><p>We can also specify -1 for the new size of at most one dimension.
In this case its size will be chosen automatically (so that the number of elements does not change).
For example</p>
<pre><code class="lang-fsharp">let b2 = ArrayND.reshape [4; 2; -1] b
</code></pre><p>reshapes <code>b</code> into a three dimensional tensor of shape $4 \times 2 \times 2$ with the value</p>
<pre><code>[[[   0    1]
  [   2    3]]
 [[   4    5]
  [   6    7]]
 [[   8    9]
  [  10   11]]
 [[  12   13]
  [  14   15]]]
</code></pre><h4 id="view-or-copy">View or copy?</h4>
<p>If the tensor to reshape has row-major order (C order), then <code>ArrayND.reshape</code> creates a new view into the existing tensor.
Otherwise the tensor is copied during the reshape operation.
If you need to ensure that no copy is performed, i.e. the original and reshaped tensor share the same memory, use the <code>ArrayND.reshapeView</code> function instead.
It will raise an error if the original tensor is not in row-major order.</p>
<h3 id="reordering-axes-and-transposing">Reordering axes and transposing</h3>
<p>The <code>ArrayND.swapDim</code> function creates a new view of a tensor with the given dimensions swapped.
For example</p>
<pre><code class="lang-fsharp">let b3 = ArrayND.swapDim 0 1 b
</code></pre><p>transpose the matrix <code>b</code> into</p>
<pre><code>[[   0    4    8   12]
 [   1    5    9   13]
 [   2    6   10   14]
 [   3    7   11   15]]
</code></pre><p>The original and tensor with swapped axes share the same memory and modifications made to one of them will affect the other one.
A matrix can also be transposed using the <code>ArrayND.transpose</code> function or the <code>.T</code> method, i.e. <code>ArrayND.transpose b</code> and <code>b.T</code> both transpose the matrix <code>b</code>.</p>
<p>The <code>ArrayND.reorderAxes</code> function can reorder axes arbitrarily.
It takes a list (of length equal to the rank of the tensor) with each element specifying the new position of the corresponding axis.
The list must be a permutation of the axes indices, i.e. duplicating or leaving out axes is not permitted.
Consider the rank three tensor <code>b2</code> from above; then</p>
<pre><code class="lang-fsharp">let b4 = ArrayND.reorderAxes [2; 0; 1] b2
</code></pre><p>creates the view <code>b4</code> with shape $2 \times 2 \times 4$.
It is important to understand that each list entry specifies where the axis <em>moves to</em>, not where it is coming from.
Thus, in this example, axis 0 becomes axis 2, axis 1 becomes axis 0 and axis 2 becomes axis 1.</p>
<h3 id="adding-axes">Adding axes</h3>
<p>The <code>ArrayND.padLeft</code> and <code>ArrayND.padRight</code> functions add a new axis of size one on the left or right respectively.
If you need to add an axis at another position, use the slicing operator with the <code>NewAxis</code> identifier.
For example</p>
<pre><code class="lang-fsharp">let b5 = b4.[*, *, NewAxis, *]
</code></pre><p>creates a view of shape $2 \times 2 \times 1 \times 4$.</p>
<h3 id="broadcasting">Broadcasting</h3>
<p>An axis of size one can be repeated multiple times with the same value.
This is called broadcasting.
Consider the $1 \times 4$ matrix</p>
<pre><code class="lang-fsharp">let c = ArrayNDHost.initIndexed [1; 4] (fun [_; i] -&gt; i) 
</code></pre><p>with value</p>
<pre><code>[[   0    1    2    3]]
</code></pre><p>We can use the <code>ArrayND.broadcastToShape</code> function,</p>
<pre><code class="lang-fsharp">let c1 = ArrayND.broadcastToShape [3; 4] c
</code></pre><p>to obtain the tensor</p>
<pre><code>[[   0    1    2    3]
 [   0    1    2    3]
 [   0    1    2    3]]
</code></pre><p>Broadcasting creates a view of the original tensor, thus the repeated dimensions do not use additional memory and changing the broadcasted view will also change the original as well as all indices of a broadcasted dimension.
Thus, in this example, executing</p>
<pre><code class="lang-fsharp">c1.[[1; 1]] &lt;- 11
printfn &quot;c1 is now\n%A&quot; c1
printfn &quot;c is now\n%A&quot; c
</code></pre><p>prints</p>
<pre><code>c1 is now
[[   0   11    2    3]
 [   0   11    2    3]
 [   0   11    2    3]]
c is now
[[   0   11    2    3]]
</code></pre><p>Broadcasting is also performed automatically when performing element-wise operations between two tensors of different, but compatible, shapes.
This will be explained in the section about element-wise tensor operations.</p>
<h2 id="tensor-operations">Tensor operations</h2>
<p>The tensor type supports most standard arithmetic operators and arithmetic functions.</p>
<h3 id="element-wise-binary-arithmetic-operators">Element-wise binary arithmetic operators</h3>
<p>The elementary operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>**</code>) are executed element-wise.
For example, consider the vectors <code>a</code> and <code>b</code>,</p>
<pre><code class="lang-fsharp">let d = ArrayNDHost.initIndexed [4] (fun [i] -&gt; float i)
let e = ArrayNDHost.initIndexed [4] (fun [i] -&gt; 10. * float i)
</code></pre><p>with values</p>
<pre><code>d = [   0.0000    1.0000    2.0000    3.0000]
e = [   0.0000   10.0000   20.0000   30.0000]
</code></pre><p>Then vector <code>f</code>,</p>
<pre><code class="lang-fsharp">let f = d + e
</code></pre><p>has the value</p>
<pre><code>[   0.0000   11.0000   22.0000   33.0000]
</code></pre><p>It is also possible to apply an operator to a tensor and a scalar of the same data type.
In this case the scalar is broadcasted (repeated) to the size of the given tensor.
For example</p>
<pre><code class="lang-fsharp">let d1 = d * 100.
</code></pre><p>results in</p>
<pre><code>d1 = [   0.0000  100.0000  200.0000  300.0000]
</code></pre><h4 id="automatic-broadcasting">Automatic broadcasting</h4>
<p>If a binary operator (for example <code>+</code>) is applied to two tensors of different shapes, the library tries to automatically broadcast both tensors to a compatible shape using the following rules.</p>
<ol>
<li>If the tensors have different ranks, the tensor with the lower rank is padded from the left with axes of size one until both tensors have the same rank.
For example, if <code>a</code> is of shape $4 \times 3 \times 1$ and <code>b</code> is of shape $2$, then <code>b</code> is padded to the shape $\mathbf{1} \times \mathbf{1} \times 2$.</li>
<li>For each dimension that has different size in both tensors and size one in one of the tensors, this dimension of the tensor with size one is broadcasted to the corresponding dimension of the other tensor.
Thus, in our example, the last dimension of <code>a</code> is broadcasted resulting in the shape $4 \times 3 \times \mathbf{2}$ and the first and second dimensions of <code>b</code> are broadcasted resulting in the shape $\mathbf{4} \times \mathbf{3} \times 2$.</li>
</ol>
<p>If the shapes still differ after applying the above rules, the operation fails.</p>
<h3 id="element-wise-arithmetic-functions">Element-wise arithmetic functions</h3>
<p>The standard F# arithmetic functions, such as <code>sin</code>, <code>cos</code>, <code>exp</code>, <code>log</code>, can also be applied to tensors.
For example</p>
<pre><code class="lang-fsharp">let f2 = sin f
</code></pre><p>calculates the sine of <code>f</code> element-wise.</p>
<h3 id="element-wise-function-application">Element-wise function application</h3>
<p>It is also possible to apply an arbitrary function element-wise using the <code>ArrayND.map</code> function.
For example</p>
<pre><code class="lang-fsharp">ArrayND.map (fun x -&gt; if x &gt; 15. then 7. + x else -1.) f
</code></pre><p>produces the tensor</p>
<pre><code>[  -1.0000   -1.0000   29.0000   40.0000]
</code></pre><p>An in-place variant that overwrites the original tensor is the <code>ArrayND.mapInplace</code> function.
The <code>ArrayND.map2</code> function takes two tensors and applies a binary function on their elements.</p>
<h3 id="arithmetic-reduction-functions">Arithmetic reduction functions</h3>
<p>The <code>ArrayND.sum</code> function computes the sum of all elements of a tensor and returns a zero-rank tensor.
Thus, in our example</p>
<pre><code class="lang-fsharp">printfn &quot;The sum of f is %.3f.&quot; (ArrayND.sum f |&gt; ArrayND.value)
</code></pre><p>prints</p>
<pre><code>The sum of f is 66.000.
</code></pre><p>The <code>ArrayND.sumAxis</code> function computes the sum over the given axis.
Thus</p>
<pre><code class="lang-fsharp">let g = ArrayNDHost.initIndexed [4; 4] (fun [y; x] -&gt; 4 * y + x)
ArrayND.sumAxis 0 g
</code></pre><p>computes the sums of all columns of the matrix</p>
<pre><code>[[   0    1    2    3]
 [   4    5    6    7]
 [   8    9   10   11]
 [  12   13   14   15]]
</code></pre><p>resulting in the vector</p>
<pre><code>[  24   28   32   36]
</code></pre><p>Likewise the <code>ArrayND.product</code> and <code>ArrayND.productAxis</code> compute the product of a tensor.</p>
<h3 id="maximum-and-minimum">Maximum and minimum</h3>
<p>The <code>ArrayND.min</code> and <code>ArrayND.max</code> compute the minimum and maximum of a tensor and return a zero-rank tensor.
Analogously <code>ArrayND.minAxis</code> and <code>ArrayND.maxAxis</code> compute the minimum and maximum over the given axis.</p>
<h3 id="matrix-multiplication">Matrix multiplication</h3>
<p>Matrix multiplication (dot product) is implemented using the <code>.*</code> operator.
This operator can be used to calculate a vector/vector product resulting in a scalar, a matrix/vector product resulting in a vector and a matrix/matrix product resulting in a matrix.</p>
<p>For example</p>
<pre><code class="lang-fsharp">let h = ArrayNDHost.initIndexed [5; 3] (fun [i; j] -&gt; 3. * float i + float j)
let i = 0.1 + ArrayNDHost.identity 3
let hi = h .* i
</code></pre><p>computes the matrix product of the $5 \times 3$ matrix <code>h</code> with the $3 \times 3$ matrix <code>i</code> resulting in the <code>5 \times 3</code> matrix <code>hi</code>.</p>
<h3 id="tensor-product">Tensor product</h3>
<p>The tensor product between two tensors can be obtained using the <code>%*</code> operator or the <code>ArrayND.tensorProduct</code> function.</p>
<h3 id="element-wise-comparison-operators">Element-wise comparison operators</h3>
<p>Element-wise comparisons are performed using the <code>====</code> (element-wise equal), <code>&lt;&lt;&lt;&lt;</code> (element-wise smaller than), <code>&gt;&gt;&gt;&gt;</code> (element-wise larger than) and <code>&lt;&lt;&gt;&gt;</code> (element-wise not equal) operators.
They return a tensor of equal shape and boolean data type.
For example</p>
<pre><code class="lang-fsharp">let j = d ==== e
</code></pre><p>has the value</p>
<pre><code>d = [true; false; false; false;]
</code></pre><h3 id="logic-reduction-operations">Logic reduction operations</h3>
<p>To check whether all elements satisfy a condition, use the <code>ArrayND.all</code> function after applying the element-wise comparison operator.
To check whether at least one element satisfies a condition, use the <code>ArrayND.any</code> function after applying the element-wise comparison operator.
Thus </p>
<pre><code class="lang-fsharp">d ==== e |&gt; ArrayND.all
</code></pre><p>has the value <code>false</code>, but</p>
<pre><code class="lang-fsharp">d ==== e |&gt; ArrayND.any
</code></pre><p>returns <code>true</code>.</p>
<h3 id="element-wise-logic-operators">Element-wise logic operators</h3>
<p>Element-wise logic operations are performed using the <code>~~~~</code> (element-wise negation), <code>&amp;&amp;&amp;&amp;</code> (element-wise and) and <code>||||</code> (element-wise or) operators.
Thus</p>
<pre><code class="lang-fsharp">~~~~j
</code></pre><p>has value</p>
<pre><code>[false; true; true; true;]
</code></pre><h2 id="disk-storage-in-hdf5-format">Disk storage in HDF5 format</h2>
<p>Tensors can be stored in industry-standard <a href="https://en.wikipedia.org/wiki/Hierarchical_Data_Format">HDF5 files</a>.
Multiple tensors can be stored in a single HDF5 file and accessed by assigning names to them.</p>
<h3 id="writing-tensors-to-disk">Writing tensors to disk</h3>
<p>The following code creates two tensors <code>k</code> and <code>l</code> and writes them into the HDF5 file <code>tensors.h5</code> in the current directory.</p>
<pre><code class="lang-fsharp">open Basics // TODO: remove after refactoring
let k = ArrayNDHost.initIndexed [5; 3] (fun [i; j] -&gt; 3. * float i + float j)
let l = ArrayNDHost.initIndexed [5] (fun [i] -&gt; 2. * float i)
let hdfFile = HDF5.OpenWrite &quot;tensors.h5&quot;
ArrayNDHDF.write hdfFile &quot;k&quot; k
ArrayNDHDF.write hdfFile &quot;l&quot; l
hdfFile.Dispose ()
</code></pre><p>The resulting file can be viewed using any HDF5 viewer, for example using the free, cross-platform <a href="https://www.hdfgroup.org/products/java/hdfview/">HDFView</a> application as shown below.</p>
<p><img src="img/hdfview.png" alt="HDFView screenshot"></p>
<h3 id="loading-tensors-from-disk">Loading tensors from disk</h3>
<p>The following code loads the tensors <code>k</code> and <code>l</code> from the previously created HDF5 file <code>tensors.h5</code> and stores them in the variables <code>k2</code> and <code>l2</code>.</p>
<pre><code class="lang-fsharp">let hdfFile2 = HDF5.OpenRead &quot;tensors.h5&quot;
let k2 : ArrayNDHostT&lt;float&gt; = ArrayNDHDF.read hdfFile2 &quot;k&quot;
let l2 : ArrayNDHostT&lt;float&gt; = ArrayNDHDF.read hdfFile2 &quot;l&quot; 
hdfFile2.Dispose ()
</code></pre><p>The data types of <code>k2</code> and <code>l2</code> must be declared explicitly, since they must be known at compile-time.
If the declared data type does not match the data type encountered in the HDF5, an error will be raised.</p>
<h2 id="reading-npy-and-npz-files-produced-by-numpy">Reading .npy and .npz files produced by Numpy</h2>
<p>For compatibility, it is possible to read <code>.npy</code> and <code>.npz</code> files produced by Numpy.
Not all features of the format are supported.
Writing <code>.npy</code> and <code>.npz</code> files is not possible; use the HDF5 format instead.</p>
<p>Use the <code>NPYFile.load</code> function to read an <code>.npy</code> file and return its contents as an <code>ArrayNDHostT</code>.
Use the <code>NPZFile.Open</code> function to open an <code>.npz</code> file and the <code>Get</code> method of the resulting object to obtain individual entries as <code>ArrayNDHostT</code>.</p>
<h2 id="cuda-gpu-support">CUDA GPU support</h2>
<p>If your workstation is equipped with a <a href="https://en.wikipedia.org/wiki/CUDA">CUDA</a> <a href="https://developer.nvidia.com/cuda-gpus">capable GPU</a>, you can transfer tensors to GPU memory and perform operations on the GPU.
GPU tensors are instances of the generic type <code>ArrayNDCudaT&lt;&#39;T&gt;</code> where <code>&#39;T</code> is the contained data type.</p>
<p><strong>Note: While tensors can be created on or transferred to the GPU, <em>currently</em> there is no supported for accelerated operations on the GPU <em>when using tensor directly</em>. Thus executing tensor operations (except slicing and view operations) on the GPU will be very slow <em>at the moment</em> and should be avoided. This is supposed to change with future versions and does <em>not</em> affect compiled functions created by the Deep.Net library.</strong></p>
<h3 id="data-transfer">Data transfer</h3>
<p>Tensors can be transferred to the GPU by using the <code>ArrayNDCuda.toDev</code> function.
Transfer back to host memory is done using the <code>ArrayNDCuda.toHost</code> function.</p>
<pre><code class="lang-fsharp">let m = seq {1 .. 10} |&gt; ArrayNDHost.ofSeq
let mGpu = ArrayNDCuda.toDev m
</code></pre><p><code>mGpu</code> is now a copy of <code>m</code> in GPU memory.</p>
<h3 id="tensor-creation">Tensor creation</h3>
<p>It is possible to create tensors directly in GPU memory.
The function <code>ArrayNDCuda.zeros</code>, <code>ArrayNDCuda.ones</code>, <code>ArrayNDCuda.identity</code> and <code>ArrayNDCuda.scalar</code> behave like their <code>ArrayNDHost</code> counterparts, except that the result is stored on the GPU.</p>
<pre><code class="lang-fsharp">let n : ArrayNDCudaT&lt;float&gt; = ArrayNDCuda.identity 4
</code></pre><p>Here we created a $4 \times 4$ identity matrix of data type <code>float</code> on the GPU.</p>
<h3 id="operators-and-functions">Operators and functions</h3>
<p>All functions and operators described in previous section can be equally applied to GPU tensors.
For example, the code</p>
<pre><code class="lang-fsharp">let mGpuSq = mGpu.[3..5] * 3
</code></pre><p>takes three elements from the GPU tensor and multiplies them by 3 on the GPU.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We presented an introduction to working with host and GPU tensors in Deep.Net.
Direct tensor manipulation will be used mostly for dataset and results handling.
The machine learning model will instead be defined as a symbolic computation graph, that supports automatic differentiation and compilation to optimized CUDA code.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/DeepMLNet/DeepNet/blob/core2/Numeric/Tensor.Docs/articles/Tutorial.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
